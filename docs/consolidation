# Forecasting Tool - Item Master Consolidation Analysis

**Date:** 2025-01-15
**Status:** Compatibility Review
**Reviewed By:** Claude (AI Assistant)

---

## Executive Summary

**Overall Assessment:** Your forecasting tool is **70% compatible** with the planned item master consolidation. However, **critical changes are needed** to handle the transition from Current State (regional codes) to Future State (consolidated codes).

**Key Findings:**
- ✅ **UoM conversion** already implemented using SAP fields (no hardcoded factors)
- ✅ **Regional suffix detection** already exists
- ❌ **No item state detection** (doesn't know if item is current vs future state)
- ❌ **No warehouse code mapping** (doesn't handle new warehouse codes)
- ⚠️ **May break during transition** when both states coexist

**Priority:** **HIGH** - Implement before consolidation date

---

## Detailed Compatibility Analysis

### ✅ Requirement 1: Detect Item Master State

**Status:** ⚠️ **PARTIAL** - Has region parsing, but no state detection

**Current Implementation:**
```python
# src/ingestion.py:19-45
def parse_region(item_code: str) -> str:
    """
    Parses the ItemCode suffix to determine the Region.
    Defaults to 'Delta' if no suffix matches or input is invalid.
    """
    suffix_map = {
        '-DEL': 'Delta',
        '-CGY': 'Calgary',
        '-EDM': 'Edmonton',
        '-SAS': 'Saskatoon',
        '-REG': 'Regina',
        '-WPG': 'Winnipeg',
        '-TOR': 'Toronto',
        '-VGH': 'Vaughan',
        '-MTL': 'Montreal'
    }

    if not isinstance(item_code, str):
        return 'Delta'

    # Check suffixes
    for suffix, region in suffix_map.items():
        if item_code.endswith(suffix):
            return region

    # Default fallback for equipment/no-suffix
    return 'Delta'
```

**Issue:** The function can detect regional suffixes, but it doesn't distinguish between:
- Current state items (with suffix): `30027C-TOR`
- Future state items (no suffix): `30027C`
- Non-regional items that never had a suffix

**Required Changes:**
```python
def get_item_state(item_code: str) -> str:
    """
    Detect if item is in current state (regional) or future state (consolidated).
    """
    if not isinstance(item_code) or not item_code:
        return 'UNKNOWN'

    # Check for regional suffix pattern (XXX-REG where REG is 3 chars)
    if '-' in item_code:
        parts = item_code.split('-')
        if len(parts) == 2 and len(parts[1]) == 3:
            return 'CURRENT'  # Regional item code

    return 'FUTURE'  # Consolidated item code
```

---

### ✅ Requirement 2: Handle Both UoM States

**Status:** ✅ **COMPATIBLE** - Already reads from SAP fields

**Current Implementation:**
```python
# src/uom_conversion_sap.py:17-129
def convert_stock_to_sales_uom_sap(df_items: pd.DataFrame) -> pd.DataFrame:
    """
    Convert stock from SAP Base UOM (Litres/kg) to Sales UOM (Pails/Drums)
    using SAP B1's native UOM conversion fields.

    SAP B1 Fields:
    - BaseUoM: Inventory UOM (e.g., 'L', 'kg') - stock is ALWAYS in this
    - SalesUoM: Sales UOM (e.g., 'Pail', 'Drum')
    - QtyPerSalesUoM: Conversion factor (e.g., 18.9 Litres per Pail)
    """
    # ... reads from BaseUoM, SalesUoM, QtyPerSalesUoM columns
    # ... converts: CurrentStock_SalesUOM = CurrentStock / QtyPerSalesUoM
```

**Good News:**
- ✅ No hardcoded conversion factors
- ✅ Reads `QtyPerSalesUoM` from data
- ✅ Vectorized conversion (fast)
- ✅ Handles current state correctly

**Issue:** After consolidation, the logic changes:
- **Current:** Convert FROM Base TO Sales (divide by factor)
- **Future:** Costs/quantities already in Purchasing UoM (no conversion needed)

**Required Changes:**
```python
def handle_uom_for_item_state(df_items: pd.DataFrame) -> pd.DataFrame:
    """
    Handle UoM based on item master state.
    """
    df_result = df_items.copy()

    # Add item state detection
    df_result['item_state'] = df_result['Item No.'].apply(get_item_state)

    # Current state: Convert from Base to Sales UoM
    current_mask = df_result['item_state'] == 'CURRENT'
    if current_mask.any():
        df_result.loc[current_mask, 'CurrentStock_SalesUOM'] = \
            df_result.loc[current_mask, 'CurrentStock'] / \
            df_result.loc[current_mask, 'QtyPerSalesUoM']

    # Future state: Already in Purchasing UoM (no conversion)
    future_mask = df_result['item_state'] == 'FUTURE'
    if future_mask.any():
        df_result.loc[future_mask, 'CurrentStock_SalesUOM'] = \
            df_result.loc[future_mask, 'CurrentStock']  # Already correct

    return df_result
```

---

### ✅ Requirement 3: Apply UoM Conversion (if needed)

**Status:** ✅ **COMPATIBLE** - Already implemented correctly

**Current Implementation:**
```python
# Vectorized conversion using data-driven factors
df_converted.loc[valid_mask, 'CurrentStock_SalesUOM'] = \
    df_converted.loc[valid_mask, 'CurrentStock'] / \
    df_converted.loc[valid_mask, 'QtyPerSalesUoM']
```

**Good News:**
- ✅ No hardcoded factors (reads from `QtyPerSalesUoM`)
- ✅ Handles any conversion factor
- ✅ Validates factors (catches NaN, zero, extreme values)

**No changes needed** - this requirement is already met!

---

### ❌ Requirement 4: Handle Warehouse Mapping

**Status:** ❌ **NOT IMPLEMENTED** - Will break after consolidation

**Current Implementation:**
```python
# src/ingestion.py:19-45
# Region extracted from item code suffix
def parse_region(item_code: str) -> str:
    # Returns: "Delta", "Calgary", etc. from suffix
```

**Issue:**
- **Current state:** Warehouse embedded in item code suffix (`-TOR` → Warehouse 50)
- **Future state:** One item, multiple warehouses (need OITW table lookup)

**Current Warehouse Codes:**
```
TOR → Warehouse 50
CGY → Warehouse 30
DEL → Warehouse 1, 3, 4, 5, 7, 9, 11, 12, 15, 21, 23, 25
EDM → Warehouse 40
REG → Warehouse 60
```

**Future Warehouse Codes:**
```
TOR → Warehouse 050-TOR1
CGY → Warehouse 030-CGY1
DEL → Warehouse 000-DEL1
EDM → Warehouse 040-EDM1
REG → Warehouse 060-REG1
```

**Required Changes:**
```python
def get_warehouses_for_item(item_code: str, item_data: dict = None,
                             df_warehouse: pd.DataFrame = None) -> list:
    """
    Get warehouse(s) for an item based on item master state.

    Current state: Single warehouse from suffix
    Future state: Multiple warehouses from OITW table
    """
    item_state = get_item_state(item_code)

    if item_state == 'CURRENT':
        # Extract from suffix
        region = parse_region(item_code)
        # Map region to warehouse code
        warehouse_map = {
            'Toronto': '50',
            'Calgary': '30',
            'Delta': '1',  # Or multiple: 1, 3, 4, 5, 7, 9...
            'Edmonton': '40',
            'Regina': '60'
        }
        return [warehouse_map.get(region, '1')]

    elif item_state == 'FUTURE':
        # Look up from warehouse data (OITW table)
        if df_warehouse is not None:
            warehouses = df_warehouse[
                df_warehouse['item_code'] == item_code
            ]['warehouse_code'].tolist()
            return warehouses if warehouses else ['000-DEL1']  # Default
        else:
            # Fallback: try to detect from region if items still tagged
            region = item_data.get('Region', 'Delta')
            new_warehouse_map = {
                'Toronto': '050-TOR1',
                'Calgary': '030-CGY1',
                'Delta': '000-DEL1',
                'Edmonton': '040-EDM1',
                'Regina': '060-REG1'
            }
            return [new_warehouse_map.get(region, '000-DEL1')]

    return ['1']  # Default
```

---

### ✅ Requirement 5: Preserve Inventory Values

**Status:** ✅ **COMPATIBLE** - Conversion preserves values

**Current Implementation:**
```python
# Converts quantities, not costs
# Value preservation: cost_base × qty_base = cost_purch × qty_purch
```

**Good News:**
- ✅ Converts quantities correctly
- ✅ Costs stored separately (not affected by UoM conversion)
- ✅ Math preserves values: $1.50/L × 1000 L = $30.00/Pail × 50 Pail = $1,500

**No changes needed** - values are preserved!

---

## Critical Issues Summary

### ❌ Issue 1: No State Detection

**Impact:** HIGH
- Tool cannot distinguish between current and future state items
- Will apply wrong logic during transition period
- May cause incorrect forecasts, purchase orders, inventory levels

**Fix Required:**
```python
def get_item_state(item_code: str) -> str:
    """Detect if item is current (regional) or future (consolidated)"""
    if '-' in item_code and len(item_code.split('-')[-1]) == 3:
        return 'CURRENT'
    return 'FUTURE'
```

### ❌ Issue 2: No Warehouse Mapping

**Impact:** HIGH
- After consolidation, cannot get correct warehouse for items
- Purchase orders may go to wrong warehouse
- Inventory reports will be incorrect

**Fix Required:**
- Add warehouse mapping logic (see above)
- Support both old and new warehouse codes during transition

### ⚠️ Issue 3: No Transition Period Handling

**Impact:** MEDIUM
- When consolidation starts, some items will be current state, some future state
- Tool must handle BOTH simultaneously
- No logic exists for this mixed state

**Fix Required:**
- Check item state for EACH item individually
- Apply correct UoM logic based on state
- Do NOT assume all items are in same state

---

## Compatibility Checklist

Based on `FORECASTING_TOOL_GUIDE.md` requirements:

### ✅ MUST Support (Current Status)

| Requirement | Status | Notes |
|-------------|--------|-------|
| Detect item master state | ⚠️ PARTIAL | Has region parsing, needs state detection |
| Handle BASE units (Litre, KG) | ✅ YES | Reads from BaseUoM field |
| Handle PURCHASING units (Pail, Drum) | ⚠️ PARTIAL | Converts TO SalesUoM, but assumes current state |
| Apply UoM conversion when needed | ✅ YES | Reads QtyPerSalesUoM from data |
| Map warehouse codes (old → new) | ❌ NO | Will break after consolidation |
| Preserve inventory values | ✅ YES | Math is correct |
| Handle regional item codes | ✅ YES | parse_region() works |
| Handle consolidated item codes | ❌ NO | No future state logic |

### ⚠️ SHOULD Support (Current Status)

| Requirement | Status | Notes |
|-------------|--------|-------|
| Graceful degradation during transition | ❌ NO | No transition period logic |
| Warning messages for mixed data states | ❌ NO | No state mixing detection |
| Conversion factor validation | ✅ YES | validate_sap_uom_data() exists |
| Historical data normalization | ❌ NO | Not applicable for TSV data |
| Dual UoM display (base + purchasing) | ⚠️ PARTIAL | Shows both, but no state context |

### ❌ MUST NOT Do (Current Status)

| Anti-Pattern | Status | Notes |
|-------------|--------|-------|
| Hardcode conversion factors | ✅ PASS | Reads from QtyPerSalesUoM |
| Assume single warehouse per item | ⚠️ WARNING | Assumes current state structure |
| Ignore inventory value preservation | ✅ PASS | Values preserved correctly |
| Mix current/future data without conversion | ⚠️ WARNING | Will mix during transition |
| Break when consolidation occurs | ❌ FAIL | WILL BREAK without fixes |

---

## Recommended Implementation Plan

### Phase 1: Add State Detection (HIGH PRIORITY)

**File:** `src/ingestion.py`

**Changes:**
1. Add `get_item_state()` function
2. Add `item_state` column to all dataframes
3. Update `load_items()` to include state

**Time:** 2 hours

### Phase 2: Update UoM Conversion Logic (HIGH PRIORITY)

**File:** `src/uom_conversion_sap.py`

**Changes:**
1. Update `convert_stock_to_sales_uom_sap()` to check item state
2. Only convert if state == 'CURRENT'
3. Skip conversion if state == 'FUTURE'

**Time:** 3 hours

### Phase 3: Add Warehouse Mapping (HIGH PRIORITY)

**File:** `src/ingestion.py` (new module)

**Changes:**
1. Create `get_warehouses_for_item()` function
2. Map old codes → new codes
3. Support multiple warehouses per item (future state)

**Time:** 4 hours

### Phase 4: Update All Modules to Use State (MEDIUM PRIORITY)

**Files:**
- `src/forecasting.py`
- `src/automated_ordering.py`
- `src/inventory_optimization.py`
- `src/data_pipeline.py`

**Changes:**
1. Check `item_state` before applying logic
2. Use correct warehouse mapping
3. Handle both states in same dataset

**Time:** 8 hours

### Phase 5: Add Transition Period Safeguards (MEDIUM PRIORITY)

**Changes:**
1. Detect mixed data states
2. Warn if both current and future items present
3. Log state distribution

**Time:** 2 hours

### Phase 6: Testing (HIGH PRIORITY)

**Test Cases:**
1. Current state items only
2. Future state items only
3. Mixed state items (transition)
4. Warehouse mapping (old codes)
5. Warehouse mapping (new codes)
6. UoM conversion accuracy

**Time:** 6 hours

**Total Estimated Time:** 25 hours (3-4 days)

---

## Testing Strategy

### Test Case 1: Current State (Before Consolidation)

```python
# Input
item_code = "30027C-TOR"
base_uom = "Litre"
purchasing_uom = "Pail"
conversion_factor = 20
stock = 1000  # Litres

# Expected Output
item_state = "CURRENT"
warehouse = "50"
stock_sales_uom = 50  # Pails
inventory_value = $1,500
```

### Test Case 2: Future State (After Consolidation)

```python
# Input
item_code = "30027C"
purchasing_uom = "Pail"
stock = 50  # Pails (already converted)

# Expected Output
item_state = "FUTURE"
warehouses = ["050-TOR1", "030-CGY1", "000-DEL1"]
stock_sales_uom = 50  # Pails (no conversion)
inventory_value = $1,500
```

### Test Case 3: Mixed State (Transition Period)

```python
# Input - some current, some future
items = ["30027C-TOR", "30027C-CGY", "30027C"]

# Expected Output
states = ["CURRENT", "CURRENT", "FUTURE"]
warehouses = ["50", "30", ["050-TOR1", "030-CGY1", "000-DEL1"]]
# Each item handled correctly based on its state
```

### Test Case 4: Conversion Accuracy

```python
# Input
1000 Litres, factor 20, cost $1.50/Litre

# Expected Output
50 Pails, cost $30.00/Pail
Value preserved: $1.50 × 1000 = $30.00 × 50 = $1,500
```

---

## Code Samples for Implementation

### Sample 1: Update load_items() to include state

```python
# src/ingestion.py
def load_items(filepath: Path) -> pd.DataFrame:
    """Load item master data with state detection."""
    df = pd.read_csv(filepath, sep='\t')

    # Add item state detection
    df['item_state'] = df['Item No.'].apply(get_item_state)

    # Log state distribution
    state_counts = df['item_state'].value_counts()
    logger.info(f"Item state distribution: {state_counts.to_dict()}")

    return df
```

### Sample 2: Update UoM conversion for state

```python
# src/uom_conversion_sap.py
def convert_stock_to_sales_uom_with_state(df_items: pd.DataFrame) -> pd.DataFrame:
    """Convert stock based on item master state."""
    df_result = df_items.copy()

    # Current state: Convert from Base to Sales UoM
    current_mask = df_result['item_state'] == 'CURRENT'
    if current_mask.any():
        df_result.loc[current_mask, 'CurrentStock_SalesUOM'] = \
            df_result.loc[current_mask, 'CurrentStock'] / \
            df_result.loc[current_mask, 'QtyPerSalesUoM']

    # Future state: Already in Purchasing UoM (no conversion needed)
    future_mask = df_result['item_state'] == 'FUTURE'
    if future_mask.any():
        df_result.loc[future_mask, 'CurrentStock_SalesUOM'] = \
            df_result.loc[future_mask, 'CurrentStock']

    return df_result
```

### Sample 3: Warehouse mapping function

```python
# src/ingestion.py
WAREHOUSE_MAP_OLD = {
    'Toronto': '50',
    'Calgary': '30',
    'Delta': '1',
    'Edmonton': '40',
    'Regina': '60'
}

WAREHOUSE_MAP_NEW = {
    'Toronto': '050-TOR1',
    'Calgary': '030-CGY1',
    'Delta': '000-DEL1',
    'Edmonton': '040-EDM1',
    'Regina': '060-REG1'
}

def get_warehouse_for_item(item_code: str, region: str) -> str:
    """Get warehouse code based on item state and region."""
    item_state = get_item_state(item_code)

    if item_state == 'CURRENT':
        return WAREHOUSE_MAP_OLD.get(region, '1')
    else:
        return WAREHOUSE_MAP_NEW.get(region, '000-DEL1')
```

---

## Risk Assessment

### HIGH RISK

**Risk:** Tool breaks when consolidation starts
**Impact:** Forecasts stop, purchase orders wrong, inventory reports incorrect
**Mitigation:** Implement state detection BEFORE consolidation date
**Timeline:** Complete at least 1 week before consolidation

### MEDIUM RISK

**Risk:** Mixed data during transition period
**Impact:** Some items correct, some wrong depending on state
**Mitigation:** Add state checking to ALL modules
**Timeline:** Test with mixed data before consolidation

### LOW RISK

**Risk:** Performance degradation
**Impact:** Slower processing due to state checking
**Mitigation:** Vectorized operations, minimal overhead
**Timeline:** Profile after implementation

---

## Recommendations

### Immediate Actions (Before Consolidation)

1. ✅ **Add state detection** to all data loading functions
2. ✅ **Update UoM conversion** to check state before converting
3. ✅ **Implement warehouse mapping** for both old and new codes
4. ✅ **Add logging** to track state distribution
5. ✅ **Create test suite** with current/future/mixed state data

### During Consolidation

1. ✅ **Monitor state distribution** in logs
2. ✅ **Validate conversion accuracy** on sample items
3. ✅ **Check warehouse assignments** are correct
4. ✅ **Verify inventory values** preserved

### After Consolidation

1. ✅ **Remove current state logic** once all items converted
2. ✅ **Update documentation** to reflect future state
3. ✅ **Archive current state code** for reference

---

## Conclusion

Your forecasting tool has a **solid foundation** for the consolidation:
- ✅ UoM conversion already implemented correctly
- ✅ No hardcoded conversion factors
- ✅ Regional suffix parsing exists

**However, critical gaps exist:**
- ❌ No item state detection
- ❌ No warehouse code mapping
- ❌ No transition period handling

**Priority: HIGH** - Implement these changes before consolidation to avoid breaking your forecasting system.

**Estimated effort:** 25 hours (3-4 days) for full implementation and testing.

**Recommended timeline:** Complete at least 1 week before planned consolidation date to allow for testing and validation.

---

## Questions for Consolidation Team

1. **When is the consolidation date?** (Need timeline)
2. **Will there be a transition period?** (Both states coexist)
3. **How will warehouse codes change?** (Confirm mapping)
4. **Will historical data be converted?** (Or stay in base units)
5. **Can we get a test dataset with future state items?** (For testing)

---

**Next Steps:**
1. Review this analysis with consolidation team
2. Confirm timeline and requirements
3. Implement Phase 1 (state detection)
4. Test with sample data
5. Complete remaining phases before consolidation
